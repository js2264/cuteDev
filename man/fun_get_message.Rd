% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fun_get_message.R
\name{fun_get_message}
\alias{fun_get_message}
\title{fun_get_message}
\usage{
fun_get_message(
  data,
  kind = "error",
  header = TRUE,
  print.no = FALSE,
  text = NULL,
  env = NULL
)
}
\arguments{
\item{data}{Single character string to evaluate.}

\item{kind}{Single character string. Either "error" to get error messages, or "warning" to get warning messages, or "message" to get non error and non warning messages.}

\item{header}{Logical. Add a header in the returned message?}

\item{print.no}{Logical. Print a message saying that no message reported?}

\item{text}{Single character string added to the output message (even if no message exists and print.no is TRUE). Inactivated if the header argument is FALSE. Write NULL if not required.}

\item{env}{The name of an existing environment. Write NULL if not required.}
}
\value{
The message or NULL if no message and print.no is FALSE.
}
\description{
Evaluate an instruction written between "" and return the first of the error, or warning or standard (non error non warning) messages if ever exist.

Using argument print.no = FALSE, return NULL if no message, which is convenient in some cases.
}
\details{
REQUIRED PACKAGES

None

REQUIRED FUNCTIONS FROM CUTE_LITTLE_R_FUNCTION

fun_check()

WARNINGS

Only the first message is returned.

Always use the env argument when fun_get_message() is used inside functions.

The function does not prevent printing if print() is used inside the instruction tested. To prevent that, use tempo <- capture.output(error <- fun_get_message(data = "fun_check(data = 'a', class = mean, neg.values = FALSE, print = TRUE)")). The return of fun_get_message() is assigned into error and the printed messages are captured by capture.output() and assigned into tempo. See the examples.

REQUIRED PACKAGES

none

REQUIRED FUNCTIONS FROM CUTE_LITTLE_R_FUNCTION

fun_check()
fun_pack()
}
\examples{
fun_get_message(data = "wilcox.test(c(1,1,3), c(1, 2, 4), paired = TRUE)", 
kind = "error", print.no = TRUE, text = "IN A")

fun_get_message(data = "wilcox.test(c(1,1,3), c(1, 2, 4), paired = TRUE)", 
kind = "warning", print.no = TRUE, text = "IN A")

fun_get_message(data = "wilcox.test(c(1,1,3), c(1, 2, 4), paired = TRUE)", 
kind = "message", print.no = TRUE, text = "IN A")

fun_get_message(data = "wilcox.test()", kind = "error", print.no = TRUE, text = "IN A")

fun_get_message(data = "sum(1)", kind = "error", print.no = TRUE, text = "IN A")

fun_get_message(data = "message('ahah')", kind = "error", print.no = TRUE, text = "IN A")

fun_get_message(data = "message('ahah')", kind = "message", print.no = TRUE, text = "IN A")

fun_get_message(data = "ggplot(data = data.frame(X = 1:10, stringsAsFactors = TRUE), 
mapping = aes(x = X)) 
+ geom_histogram()", kind = "message", print.no = TRUE, text = "IN FUNCTION 1")

set.seed(1) ; 
obs1 <- data.frame(Time = c(rnorm(10), rnorm(10) + 2), 
Group1 = rep(c("G", "H"), each = 10), stringsAsFactors = TRUE) ; 
fun_get_message(data = 'fun_gg_boxplot(data = obs1, y = "Time", categ = "Group1")', 
kind = "message", print.no = TRUE, text = "IN FUNCTION 1")

}
